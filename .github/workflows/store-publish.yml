name: Publish to Microsoft Store

on:
  push:
    tags:
      - 'store-v*'  # Trigger on tags like store-v1.0.0
  workflow_dispatch:  # Allow manual trigger
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0.0)'
        required: true
        default: '1.0.0.0'

permissions:
  contents: write

env:
  PYTHON_VERSION: '3.10'
  PACKAGE_NAME: 'CameraReactions'  # Used for executable name only
  STORE_PACKAGE_NAME: 'TysonCung.CameraReactions'  # Official Store identity
  PUBLISHER_NAME: 'CN=41EE912E-ED98-4C96-BEAF-8F0414555D6F'  # Publisher ID from Partner Center

jobs:
  build-msix:
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller

    - name: Build executable with PyInstaller
      run: |
        pyinstaller --name ${{ env.PACKAGE_NAME }} `
          --windowed `
          --onefile `
          --hidden-import=mediapipe `
          --hidden-import=cv2 `
          src/main.py
      shell: pwsh

    - name: Get version from tag or input
      id: get_version
      run: |
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $version = "${{ github.event.inputs.version }}"
        } else {
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace 'store-v', ''
          # Ensure 4-part version (e.g., 1.0 -> 1.0.0.0)
          $parts = $version -split '\.'
          while ($parts.Length -lt 4) {
            $parts += "0"
          }
          $version = $parts -join '.'
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "Version: $version"
      shell: pwsh

    - name: Create AppxManifest.xml
      run: |
        $version = "${{ steps.get_version.outputs.VERSION }}"
        $manifest = @"
        <?xml version="1.0" encoding="utf-8"?>
        <Package
          xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
          xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
          xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">

          <Identity
            Name="${{ env.STORE_PACKAGE_NAME }}"
            Publisher="${{ env.PUBLISHER_NAME }}"
            Version="$version" />

          <Properties>
            <DisplayName>Camera Reactions</DisplayName>
            <PublisherDisplayName>Tyson Cung</PublisherDisplayName>
            <Logo>Assets\StoreLogo.png</Logo>
            <Description>Add animated reactions to video calls with hand gestures</Description>
          </Properties>

          <Dependencies>
            <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.22000.0" />
          </Dependencies>

          <Resources>
            <Resource Language="en-us" />
          </Resources>

          <Applications>
            <Application Id="${{ env.PACKAGE_NAME }}" Executable="${{ env.PACKAGE_NAME }}.exe" EntryPoint="Windows.FullTrustApplication">
              <uap:VisualElements
                DisplayName="Camera Reactions"
                Description="Gesture-controlled animated effects for video calls"
                BackgroundColor="transparent"
                Square150x150Logo="Assets\Square150x150Logo.png"
                Square44x44Logo="Assets\Square44x44Logo.png">
                <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
                <uap:SplashScreen Image="Assets\SplashScreen.png" />
              </uap:VisualElements>
            </Application>
          </Applications>

          <Capabilities>
            <rescap:Capability Name="runFullTrust" />
            <Capability Name="internetClient" />
            <DeviceCapability Name="webcam" />
            <DeviceCapability Name="microphone" />
          </Capabilities>
        </Package>
        "@

        New-Item -Path "msix" -ItemType Directory -Force
        $manifest | Out-File -FilePath "msix\AppxManifest.xml" -Encoding utf8
      shell: pwsh

    - name: Create MSIX package structure
      run: |
        # Create directory structure
        New-Item -Path "msix\Assets" -ItemType Directory -Force

        # Copy executable
        Copy-Item "dist\${{ env.PACKAGE_NAME }}.exe" -Destination "msix\${{ env.PACKAGE_NAME }}.exe"

        # Copy real assets from repository
        if (Test-Path "assets\store") {
          Copy-Item "assets\store\*" -Destination "msix\Assets\" -Force
          Write-Host "✓ Copied store assets from assets/store/"
        } else {
          Write-Error "Assets directory not found. Please create assets/store/ with required PNGs."
          exit 1
        }
      shell: pwsh

    - name: Install Windows SDK
      run: |
        choco install windows-sdk-10-version-2004-all -y
      shell: pwsh

    - name: Create self-signed certificate (for testing)
      run: |
        $cert = New-SelfSignedCertificate `
          -Type Custom `
          -Subject "${{ env.PUBLISHER_NAME }}" `
          -KeyUsage DigitalSignature `
          -FriendlyName "Camera Reactions Test Cert" `
          -CertStoreLocation "Cert:\CurrentUser\My" `
          -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3", "2.5.29.19={text}")

        $pwd = ConvertTo-SecureString -String "TestPassword123" -Force -AsPlainText
        Export-PfxCertificate -Cert "Cert:\CurrentUser\My\$($cert.Thumbprint)" `
          -FilePath "TestCert.pfx" `
          -Password $pwd

        echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Build MSIX package
      run: |
        # Find MakeAppx.exe (x64 version)
        $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "makeappx.exe" -Recurse | Where-Object { $_.FullName -match "\\x64\\" } | Select-Object -First 1

        if ($makeappx) {
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $outputFile = "${{ env.PACKAGE_NAME }}_${version}_x64.msix"

          & $makeappx.FullName pack /d msix /p $outputFile /o

          echo "MSIX_PATH=$outputFile" >> $env:GITHUB_ENV
          echo "Created MSIX: $outputFile"
        } else {
          Write-Error "MakeAppx.exe not found"
          exit 1
        }
      shell: pwsh

    - name: Sign MSIX package (for testing)
      run: |
        # Find SignTool.exe (x64 version)
        $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "signtool.exe" -Recurse | Where-Object { $_.FullName -match "\\x64\\" } | Select-Object -First 1

        if ($signtool) {
          & $signtool.FullName sign /fd SHA256 /a /f TestCert.pfx /p "TestPassword123" $env:MSIX_PATH
          echo "Signed MSIX package"
        } else {
          Write-Error "SignTool.exe not found"
        }
      shell: pwsh

    - name: Upload MSIX artifact
      uses: actions/upload-artifact@v5
      with:
        name: msix-package
        path: ${{ env.PACKAGE_NAME }}_*.msix
        retention-days: 30

    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ env.PACKAGE_NAME }}_*.msix
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  submit-to-store:
    needs: build-msix
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/store-v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download MSIX artifact
      uses: actions/download-artifact@v5
      with:
        name: msix-package

    - name: Install StoreBroker PowerShell module
      run: |
        Install-Module -Name StoreBroker -Force -Scope CurrentUser
        Import-Module StoreBroker
      shell: pwsh

    - name: Configure StoreBroker
      run: |
        $configPath = "$env:USERPROFILE\.StoreBroker"

        # Create StoreBroker directory if it doesn't exist
        New-Item -Path $configPath -ItemType Directory -Force | Out-Null

        $config = @{
          tenantId = "${{ secrets.AZURE_TENANT_ID }}"
          clientId = "${{ secrets.AZURE_CLIENT_ID }}"
          clientSecret = "${{ secrets.AZURE_CLIENT_SECRET }}"
        }

        # Store credentials securely
        $config | ConvertTo-Json | Out-File "$configPath\config.json"
      shell: pwsh
      env:
        AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}

    - name: Submit to Microsoft Store
      run: |
        # Authenticate with Azure AD
        $clientId = "${{ secrets.AZURE_CLIENT_ID }}"
        $clientSecret = "${{ secrets.AZURE_CLIENT_SECRET }}"
        $tenantId = "${{ secrets.AZURE_TENANT_ID }}"

        Write-Host "Authenticating with Azure AD..."
        $securePassword = ConvertTo-SecureString $clientSecret -AsPlainText -Force
        $credential = New-Object System.Management.Automation.PSCredential($clientId, $securePassword)

        # Set StoreBroker authentication
        Set-StoreBrokerAuthentication -TenantId $tenantId -Credential $credential

        # Get the MSIX file
        $msixFile = Get-ChildItem -Filter "*.msix" | Select-Object -First 1
        Write-Host "Found MSIX package: $($msixFile.Name)"

        # Get the App ID from secrets
        $appId = "${{ secrets.STORE_APP_ID }}"
        Write-Host "Submitting to Store with App ID: $appId"

        # Get app info to check for pending submission
        Write-Host "Checking for existing submission..."
        $app = Get-Application -AppId $appId

        # Check if there's already a pending submission
        if ($app.pendingApplicationSubmission) {
          Write-Host "Found existing pending submission, using it..."
          $submissionId = $app.pendingApplicationSubmission.id
        } else {
          Write-Host "No pending submission found, creating new one..."
          $newSubmission = New-ApplicationSubmission -AppId $appId -Force
          $submissionId = $newSubmission.id
        }

        Write-Host "Using store-submission.json for submission data..."
        $tempSubmissionPath = "temp-submission.json"

        # Use our store-submission.json file instead of downloading from Microsoft Store
        Copy-Item "store-submission.json" $tempSubmissionPath

        $submissionData = Get-Content $tempSubmissionPath -Raw | ConvertFrom-Json
        Write-Host "Application Category: $($submissionData.applicationCategory)"
        Write-Host "Pricing: $($submissionData.pricing.priceId)"

        Write-Host "Preparing submission with package information..."
        try {
          # Step 1: Load the submission data and add package info
          $submissionData = Get-Content $tempSubmissionPath -Raw | ConvertFrom-Json

          # Add the package information to the applicationPackages array
          $packageInfo = @{
            fileName = $msixFile.Name
            fileStatus = "PendingUpload"
            minimumDirectXVersion = "None"
            minimumSystemRam = "None"
          }

          # Ensure applicationPackages is an array
          if (-not $submissionData.applicationPackages) {
            $submissionData.applicationPackages = @()
          }
          $submissionData.applicationPackages += $packageInfo
          Write-Host "Added package to submission data: $($msixFile.Name)"

          # Save the updated submission data back to file
          $submissionData | ConvertTo-Json -Depth 10 | Out-File $tempSubmissionPath -Encoding utf8
          Write-Host "Updated submission JSON file with package info"

          # Step 2: Update submission with all data including packages
          Write-Host ""
          Write-Host "Updating submission with metadata and package info..."
          $submission = Update-ApplicationSubmission `
            -AppId $appId `
            -SubmissionId $submissionId `
            -SubmissionDataPath $tempSubmissionPath `
            -UpdateAppProperties `
            -UpdateListings `
            -UpdatePublishModeAndVisibility `
            -UpdatePricingAndAvailability `
            -UpdateNotesForCertification `
            -ReplacePackages

          Write-Host "✓ Submission updated with metadata and package info"
          Write-Host "Submission ID: $($submission.id)"
          Write-Host "Upload URL: $($submission.fileUploadUrl)"

          # Step 3: Upload the package file to Azure Storage
          Write-Host ""
          Write-Host "Uploading package file to Azure Storage..."

          # Create ZIP file for upload
          $packageZip = "package.zip"
          Compress-Archive -Path $msixFile.FullName -DestinationPath $packageZip -Force

          # Upload to the fileUploadUrl
          Upload-SubmissionPackage -PackagePath $packageZip -UploadUrl $submission.fileUploadUrl
          Write-Host "✓ Package uploaded successfully"

          # Step 4: Commit the submission
          Write-Host ""
          Write-Host "Committing submission..."
          Complete-ApplicationSubmission -AppId $appId -SubmissionId $submission.id

          Write-Host "✓ Successfully submitted to Microsoft Store!"
          Write-Host "Submission ID: $($submission.id)"
          Write-Host "Check status at: https://partner.microsoft.com/dashboard"
        } catch {
          Write-Host "Submission failed: $_"
          Write-Host "Error details: $($_.Exception.Message)"

          # Fallback message
          Write-Host ""
          Write-Host "MSIX package is ready for manual submission: $($msixFile.Name)"
          Write-Host "Please submit manually at Partner Center: https://partner.microsoft.com/dashboard"

          # Don't fail the build - package was created successfully
          exit 0
        }
      shell: pwsh
      env:
        AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        STORE_APP_ID: ${{ secrets.STORE_APP_ID }}
